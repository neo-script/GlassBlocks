<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>GlassBlocks</title>

<link rel="icon" href="favicon.ico">
<link href="https://fonts.googleapis.com/css2?family=Shizuru&display=swap" rel="stylesheet">

<style>
:root{
  --gap: 6px;
  --radius: 10px;
  --piece-pad: 10px;
}

*{ box-sizing:border-box; user-select:none; -webkit-tap-highlight-color:transparent; }

body{
  margin:0;
  font-family:'Shizuru', cursive;
  letter-spacing:.5px;
  color:#fff;
  background: radial-gradient(circle at top, #1e293b, #0f172a);
  min-height:100vh;
  display:flex;
  align-items:center;
  justify-content:center;
  overflow:hidden;
}

/* On-screen crash banner (so game doesn't "vanish" silently) */
#crashBanner{
  position:fixed;
  top:12px;
  left:50%;
  transform:translateX(-50%);
  z-index:99999;
  max-width:min(720px, 92vw);
  padding:10px 14px;
  border-radius:14px;
  background:rgba(220,38,38,.92);
  border:1px solid rgba(255,255,255,.25);
  box-shadow:0 16px 40px rgba(0,0,0,.45);
  display:none;
  font-size:16px;
}
#crashBanner code{ font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }

/* üåßÔ∏è emoji rain */
.emoji-rain{
  position:fixed;
  inset:0;
  pointer-events:none;
  z-index:0;
  overflow:hidden;
}
.emoji{
  position:absolute;
  top:-20%;
  opacity:.32;
  animation-name: fall, drift;
  animation-timing-function: linear, ease-in-out;
  animation-iteration-count: infinite, infinite;
  will-change: transform;
}
@keyframes fall { to { transform: translateY(130vh); } }
@keyframes drift{
  0%{ margin-left:0; }
  50%{ margin-left:26px; }
  100%{ margin-left:0; }
}

/* game layer */
.game{
  position:relative;
  z-index:2;
  width:min(520px, 94vw);
  display:flex;
  flex-direction:column;
  gap:16px;
}

/* header */
.header{
  display:flex;
  justify-content:space-between;
  font-size:20px;
}

/* board */
.board{
  width:100%;
  max-width:420px;
  align-self:center;

  display:grid;
  grid-template-columns:repeat(8,1fr);
  gap:var(--gap);
  padding:var(--gap);

  background:rgba(30,41,59,.75);
  border-radius:22px;
  box-shadow:0 25px 60px rgba(0,0,0,.6);
  backdrop-filter: blur(10px);

  aspect-ratio:1;
}

.cell{
  background:rgba(15,23,42,.65);
  border-radius:var(--radius);
  box-shadow: inset 0 3px 6px rgba(0,0,0,.35);
}

.cell.filled{
  box-shadow:
    0 0 0 1px rgba(255,255,255,.12),
    0 0 12px var(--glow);
}

.cell.clearing{
  animation: clear .42s ease-out forwards;
}
@keyframes clear{
  0%{ filter:brightness(2.2); opacity:1; transform:scale(1); }
  100%{ filter:brightness(1); opacity:0; transform:scale(.75); }
}

/* tray */
.tray{
  background:rgba(30,41,59,.55);
  border-radius:22px;
  padding:20px 22px;

  min-height:210px;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.25),
    0 18px 40px rgba(0,0,0,.55);
  backdrop-filter: blur(12px);
}

.pieces{
  display:flex;
  justify-content:space-around;
  align-items:center;
  gap:14px;
  height:150px;
}

/* pieces */
.piece{
  display:grid;
  gap:var(--gap);
  padding:var(--piece-pad);
  cursor:grab;
  touch-action:none;
}
.piece.dragging{ opacity:0; pointer-events:none; }

.piece-cell{
  border-radius:6px;
  background:linear-gradient(135deg,var(--c1),var(--c2));
  box-shadow:0 0 10px var(--c2);
}

/* drag proxy */
.drag-proxy{
  position:fixed;
  pointer-events:none;
  display:grid;
  gap:var(--gap);
  padding:var(--piece-pad);
  z-index:9999;
  filter: drop-shadow(0 22px 32px rgba(0,0,0,.6));
}
.drag-proxy.wiggle{
  animation: wiggle .9s ease-in-out infinite;
}
@keyframes wiggle{
  0%{ transform:translate(0,0) scale(1.06); }
  50%{ transform:translate(0,-4px) scale(1.06); }
  100%{ transform:translate(0,0) scale(1.06); }
}

/* game over overlay */
.overlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.72);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:10;
}
.overlay.show{ display:flex; }

.modal{
  background:rgba(30,41,59,.92);
  border:1px solid rgba(255,255,255,.08);
  padding:30px;
  border-radius:20px;
  text-align:center;
  box-shadow:0 30px 60px rgba(0,0,0,.65);
  width:min(420px, 88vw);
}
.modal h2{ margin:0 0 6px; }
.modal p{ margin:8px 0 0; opacity:.9; }

.modal button{
  margin-top:14px;
  padding:10px 18px;
  border-radius:999px;
  border:none;
  cursor:pointer;
  font-family:'Shizuru', cursive;
  background: linear-gradient(135deg, #22d3ee, #0ea5e9);
  color:#0f172a;
}

/* audio button */
.audio-btn{
  position:fixed;
  bottom:14px;
  right:14px;
  z-index:20;
  background:rgba(30,41,59,.7);
  border:1px solid rgba(255,255,255,.2);
  border-radius:999px;
  padding:10px 14px;
  cursor:pointer;
  font-family:'Shizuru', cursive;
  color:white;
  backdrop-filter: blur(6px);
  transition: opacity .15s ease;
}
.audio-btn.off{ opacity:.65; }
/* ‚Äúenabled but not unlocked yet‚Äù (pre-gesture) */
.audio-btn.locked{ opacity:.7; }
</style>
</head>

<body>

<div id="crashBanner"></div>

<!-- AUDIO -->
<audio id="bgm" src="music.mp3" loop preload="auto"></audio>
<audio id="sfx" src="click.mp3" preload="auto"></audio>
<button id="audioBtn" class="audio-btn" aria-label="Toggle audio">üîá</button>

<div class="emoji-rain" id="rain"></div>

<div class="game">
  <div class="header">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>

  <div id="board" class="board"></div>

  <div class="tray">
    <div id="pieces" class="pieces"></div>
  </div>
</div>

<div id="proxy" class="drag-proxy" style="display:none;"></div>

<div id="gameOver" class="overlay">
  <div class="modal">
    <h2>No Space Left</h2>
    <p>Final Score: <span id="finalScore">0</span></p>
    <button id="restartBtn">Restart</button>
  </div>
</div>

<script>
'use strict';

/* =========================
   CRASH BANNER
========================= */
const crashBanner = document.getElementById('crashBanner');
function showCrash(msg){
  crashBanner.style.display = 'block';
  crashBanner.innerHTML =
    'GlassBlocks crashed: <code>' + String(msg).replace(/</g,'&lt;') + '</code><br>' +
    'Open DevTools Console for details.';
}
window.addEventListener('error', (e)=>{ console.error(e); showCrash(e.message || e.error); });
window.addEventListener('unhandledrejection', (e)=>{ console.error(e); showCrash(e.reason || 'Promise rejection'); });

/* =========================
   AUDIO (truthful UI)
   - Button NEVER lies now:
     OFF -> üîá
     ON but not unlocked yet -> üîä (dimmed)
     ON + playing allowed -> üîä (normal)
========================= */
const bgm = document.getElementById('bgm');
const sfx = document.getElementById('sfx');
const audioBtn = document.getElementById('audioBtn');

const AUDIO_KEY = 'glassblocks_audio'; // 'on' | 'off'
let audioEnabled = (localStorage.getItem(AUDIO_KEY) || 'on') === 'on';
let audioUnlocked = false;

bgm.volume = 0.35;
sfx.volume = 0.7;

function updateAudioUI(){
  // icon reflects preference
  audioBtn.textContent = audioEnabled ? 'üîä' : 'üîá';
  audioBtn.classList.toggle('off', !audioEnabled);

  // if enabled but not yet unlocked, show locked styling + helpful label
  const locked = audioEnabled && !audioUnlocked;
  audioBtn.classList.toggle('locked', locked);
  audioBtn.title = locked ? 'Tap anywhere to start music' : '';
}
updateAudioUI();

function attemptStartMusic(){
  if (!audioEnabled) return;
  bgm.play().then(()=>{
    // success: unlocked
    audioUnlocked = true;
    updateAudioUI();
  }).catch(()=>{
    // still locked; UI will remain ‚Äúlocked‚Äù
  });
}

// First gesture: unlock + start if enabled
window.addEventListener('pointerdown', () => {
  // Mark unlocked only when play actually succeeds
  attemptStartMusic();
}, { once:true });

audioBtn.addEventListener('click', () => {
  // Toggle preference
  audioEnabled = !audioEnabled;
  localStorage.setItem(AUDIO_KEY, audioEnabled ? 'on' : 'off');

  if (!audioEnabled){
    bgm.pause();
  } else {
    // if user turned it on via button, try to start immediately
    attemptStartMusic();
  }

  updateAudioUI();
});

function playClick(){
  if (!audioEnabled || !audioUnlocked) return;
  try{
    sfx.currentTime = 0;
    sfx.play().catch(()=>{});
  } catch {}
}

/* =========================
   RAIN
========================= */
const rain = document.getElementById('rain');
const SYMBOLS = ['‚úØ','‚ú¶','‚úß','‚ú©','‚òÖ','‚òÜ','‚≠ë'];
const RAIN_COUNT = 55;

for (let i=0; i<RAIN_COUNT; i++){
  const s = document.createElement('span');
  s.className = 'emoji';
  s.textContent = SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)];

  const left = Math.random()*100;
  const size = 12 + Math.random()*18;
  const fallDur = 10 + Math.random()*18;
  const driftDur = 3.5 + Math.random()*4.5;
  const delay = -Math.random()*fallDur;

  s.style.left = left + '%';
  s.style.fontSize = size + 'px';
  s.style.animationDuration = `${fallDur}s, ${driftDur}s`;
  s.style.animationDelay = `${delay}s, 0s`;

  rain.appendChild(s);
}

/* =========================
   GAME DATA
========================= */
const GRID = 8;
const HAND_SCALE = 0.85;
const CLEAR_MS = 420;

const COLORS = [
  {c1:'#22d3ee', c2:'#67e8f9'},
  {c1:'#a78bfa', c2:'#c4b5fd'},
  {c1:'#34d399', c2:'#6ee7b7'},
  {c1:'#f472b6', c2:'#f9a8d4'},
  {c1:'#facc15', c2:'#fde68a'},
];

const BASE_SHAPES = [
  [[1]],
  [[1,1]],
  [[1,1,1]],
  [[1,1,1,1]],
  [[1,1],[1,1]],
  [[1,1,1],[0,1,0]],
  [[0,1,1],[1,1,0]],
  [[1,0],[1,0],[1,1]],
  [[1,1,1],[1,0,0]],
  [[0,1,0],[1,1,1],[0,1,0]],
  [[1,0,1],[1,1,1]],
];

function rotate(shape){ return shape[0].map((_,i)=>shape.map(r=>r[i]).reverse()); }
function flip(shape){ return shape.map(r=>[...r].reverse()); }
function key(shape){ return shape.map(r=>r.join('')).join('|'); }
function genShapes(base){
  const m = new Map();
  for(const s of base){
    let cur = s;
    for(let i=0;i<4;i++){
      m.set(key(cur), cur);
      m.set(key(flip(cur)), flip(cur));
      cur = rotate(cur);
    }
  }
  return [...m.values()];
}
const SHAPES = genShapes(BASE_SHAPES);
function cloneShape(shape){ return shape.map(row => row.slice()); }

/* =========================
   STATE + DOM
========================= */
let score = 0;
let best = Number(localStorage.getItem('glassblocks_best') || 0);

const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
bestEl.textContent = best;

const board = Array.from({length:GRID},()=>Array(GRID).fill(null));

const boardEl = document.getElementById('board');
const piecesEl = document.getElementById('pieces');
const proxy = document.getElementById('proxy');

const overlay = document.getElementById('gameOver');
const finalScoreEl = document.getElementById('finalScore');
const restartBtn = document.getElementById('restartBtn');

/* =========================
   BOARD
========================= */
function renderBoard(){
  boardEl.innerHTML = '';
  for(let r=0;r<GRID;r++){
    for(let c=0;c<GRID;c++){
      const d = document.createElement('div');
      d.className = 'cell';
      d.dataset.r = String(r);
      d.dataset.c = String(c);
      boardEl.appendChild(d);
    }
  }
}

/* =========================
   SIZING
========================= */
function boardCellSize(){
  const first = boardEl.querySelector('.cell');
  return first ? first.getBoundingClientRect().width : 0;
}
function syncHandSizes(){
  const s = boardCellSize();
  const hand = Math.max(10, Math.floor(s * HAND_SCALE));
  document.querySelectorAll('.piece-cell').forEach(el=>{
    el.style.width = hand + 'px';
    el.style.height = hand + 'px';
  });
}
function syncProxySizes(){
  const s = boardCellSize();
  proxy.querySelectorAll('.piece-cell').forEach(el=>{
    el.style.width = s + 'px';
    el.style.height = s + 'px';
  });
}
window.addEventListener('resize', ()=>{
  syncHandSizes();
  if(drag.active) syncProxySizes();
});

/* =========================
   PIECES
========================= */
function spawnPieces(){
  piecesEl.innerHTML = '';
  for(let i=0;i<3;i++){
    const shape = cloneShape(SHAPES[Math.floor(Math.random() * SHAPES.length)]);
    const color = COLORS[Math.floor(Math.random() * COLORS.length)];

    const p = document.createElement('div');
    p.className = 'piece';
    p._shape = shape;
    p._color = color;
    p.style.gridTemplateColumns = `repeat(${shape[0].length}, 1fr)`;

    for(const v of shape.flat()){
      const d = document.createElement('div');
      if(v){
        d.className = 'piece-cell';
        d.style.setProperty('--c1', color.c1);
        d.style.setProperty('--c2', color.c2);
      }
      p.appendChild(d);
    }

    p.addEventListener('pointerdown', startDrag);
    piecesEl.appendChild(p);
  }

  requestAnimationFrame(()=>{
    syncHandSizes();
    checkGameOver();
  });
}

/* =========================
   DRAG
========================= */
const drag = {
  active:false,
  piece:null,
  shape:null,
  color:null,
  pid:null,
  offsetX:0,
  offsetY:0,
  pad:0
};

function buildProxy(){
  proxy.replaceChildren();
  proxy.style.gridTemplateColumns = `repeat(${drag.shape[0].length}, 1fr)`;

  for(const v of drag.shape.flat()){
    const d = document.createElement('div');
    if(v){
      d.className = 'piece-cell';
      d.style.setProperty('--c1', drag.color.c1);
      d.style.setProperty('--c2', drag.color.c2);
    }
    proxy.appendChild(d);
  }

  proxy.classList.add('wiggle');
  proxy.style.display = 'grid';
  syncProxySizes();
}

function startDrag(e){
  e.preventDefault();
  if(drag.active || overlay.classList.contains('show')) return;

  drag.active = true;
  drag.piece = e.currentTarget;
  drag.shape = drag.piece._shape;
  drag.color = drag.piece._color;
  drag.pid = e.pointerId;

  const pieceRect = drag.piece.getBoundingClientRect();
  drag.offsetX = e.clientX - pieceRect.left;
  drag.offsetY = e.clientY - pieceRect.top;

  drag.pad = parseFloat(getComputedStyle(drag.piece).paddingLeft) || 0;

  drag.piece.classList.add('dragging');
  buildProxy();
  moveProxy(e.clientX, e.clientY);

  drag.piece.setPointerCapture(e.pointerId);

  window.addEventListener('pointermove', onMove, {passive:false});
  window.addEventListener('pointerup', onUp, {passive:false});
  window.addEventListener('pointercancel', onCancel, {passive:false});
}

function moveProxy(x,y){
  proxy.style.left = (x - drag.offsetX) + 'px';
  proxy.style.top  = (y - drag.offsetY) + 'px';
}

function onMove(e){
  if(!drag.active || e.pointerId !== drag.pid) return;
  e.preventDefault();
  moveProxy(e.clientX, e.clientY);
}

function onUp(e){
  if(!drag.active || e.pointerId !== drag.pid) return;
  e.preventDefault();

  const placed = tryPlace(e.clientX, e.clientY);

  if(!placed){
    drag.piece.classList.remove('dragging');
    cleanupDrag();
    checkGameOver();
    return;
  }

  cleanupDrag();
}

function onCancel(e){
  if(!drag.active || e.pointerId !== drag.pid) return;
  drag.piece.classList.remove('dragging');
  cleanupDrag();
  checkGameOver();
}

function cleanupDrag(){
  drag.active = false;
  drag.piece = null;
  drag.shape = null;
  drag.color = null;
  drag.pid = null;

  proxy.classList.remove('wiggle');
  proxy.style.display = 'none';
  proxy.replaceChildren();

  window.removeEventListener('pointermove', onMove);
  window.removeEventListener('pointerup', onUp);
  window.removeEventListener('pointercancel', onCancel);
}

/* =========================
   PLACEMENT
========================= */
function boardGapPx(){
  const g = parseFloat(getComputedStyle(boardEl).gap);
  return Number.isFinite(g) ? g : 0;
}

function canPlaceShape(shape, r, c){
  for(let i=0;i<shape.length;i++){
    for(let j=0;j<shape[i].length;j++){
      if(!shape[i][j]) continue;
      const rr = r+i, cc = c+j;
      if(rr<0 || cc<0 || rr>=GRID || cc>=GRID) return false;
      if(board[rr][cc]) return false;
    }
  }
  return true;
}

function tryPlace(pointerX, pointerY){
  const boardRect = boardEl.getBoundingClientRect();
  const size = boardCellSize();
  const gap = boardGapPx();
  const step = size + gap;

  if(pointerX < boardRect.left || pointerY < boardRect.top ||
     pointerX > boardRect.right || pointerY > boardRect.bottom) return false;

  const proxyLeft = pointerX - drag.offsetX;
  const proxyTop  = pointerY - drag.offsetY;

  const contentLeft = proxyLeft + drag.pad;
  const contentTop  = proxyTop  + drag.pad;

  let col = Math.round((contentLeft - boardRect.left) / step);
  let row = Math.round((contentTop  - boardRect.top)  / step);

  const h = drag.shape.length;
  const w = drag.shape[0].length;
  row = Math.max(0, Math.min(GRID - h, row));
  col = Math.max(0, Math.min(GRID - w, col));

  if(!canPlaceShape(drag.shape, row, col)) return false;

  placeShape(row, col);
  playClick();
  drag.piece.remove();

  if(!piecesEl.querySelector('.piece')){
    spawnPieces();
  }

  postMove();
  return true;
}

function placeShape(r,c){
  let blocks = 0;

  for(let i=0;i<drag.shape.length;i++){
    for(let j=0;j<drag.shape[i].length;j++){
      if(!drag.shape[i][j]) continue;

      board[r+i][c+j] = drag.color;
      blocks++;

      const el = document.querySelector(`.cell[data-r="${r+i}"][data-c="${c+j}"]`);
      el.classList.add('filled');
      el.style.background = `linear-gradient(135deg, ${drag.color.c1}, ${drag.color.c2})`;
      el.style.setProperty('--glow', drag.color.c2);
    }
  }

  score += blocks * 10;
  updateScore();
}

function updateScore(){
  scoreEl.textContent = String(score);
  if(score > best){
    best = score;
    bestEl.textContent = String(best);
    localStorage.setItem('glassblocks_best', String(best));
  }
}

/* =========================
   CLEARING
========================= */
function clearLines(){
  const rows = [];
  const cols = [];

  for(let r=0;r<GRID;r++){
    if(board[r].every(v=>v)) rows.push(r);
  }
  for(let c=0;c<GRID;c++){
    if(board.every(row=>row[c])) cols.push(c);
  }

  if(!rows.length && !cols.length) return false;

  const toClear = new Set();
  for(const r of rows) for(let c=0;c<GRID;c++) toClear.add(`${r},${c}`);
  for(const c of cols) for(let r=0;r<GRID;r++) toClear.add(`${r},${c}`);

  toClear.forEach(key=>{
    const [r,c] = key.split(',').map(Number);
    const el = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
    el.classList.add('clearing');
    el.classList.remove('filled');
  });

  const lines = rows.length + cols.length;
  score += (toClear.size * 6) + (lines * 60);
  updateScore();

  setTimeout(()=>{
    toClear.forEach(key=>{
      const [r,c] = key.split(',').map(Number);
      board[r][c] = null;

      const el = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
      el.className = 'cell';
      el.style.background = '';
      el.style.removeProperty('--glow');
    });
  }, CLEAR_MS);

  return true;
}

function postMove(){
  const didClear = clearLines();
  if(didClear){
    setTimeout(()=>checkGameOver(), CLEAR_MS + 30);
  } else {
    checkGameOver();
  }
}

/* =========================
   GAME OVER
========================= */
function checkGameOver(){
  if(overlay.classList.contains('show')) return;

  const remaining = [...piecesEl.querySelectorAll('.piece')];
  if(remaining.length === 0) return;

  for(const p of remaining){
    const shape = p._shape;
    for(let r=0;r<GRID;r++){
      for(let c=0;c<GRID;c++){
        if(canPlaceShape(shape, r, c)) return;
      }
    }
  }

  finalScoreEl.textContent = String(score);
  overlay.classList.add('show');
}

/* =========================
   RESTART (no reload => music keeps playing)
========================= */
function restartGame(){
  for(let r=0;r<GRID;r++){
    for(let c=0;c<GRID;c++){
      board[r][c] = null;
    }
  }

  score = 0;
  updateScore();

  document.querySelectorAll('.cell').forEach(cell=>{
    cell.className = 'cell';
    cell.style.background = '';
    cell.style.removeProperty('--glow');
  });

  overlay.classList.remove('show');
  spawnPieces();
}
restartBtn.addEventListener('click', restartGame);

/* =========================
   INIT
========================= */
function init(){
  renderBoard();
  spawnPieces();
  requestAnimationFrame(()=>syncHandSizes());
  checkGameOver();

  // make button honest on load
  // if enabled but locked, it shows "locked" dim state + tooltip
  updateAudioUI();
}
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
